% This fixes the balance on the first page.

\section{Introduction}
\label{sec:intro}

Custom wireless protocols are being designed and deployed to meet the specific
performance and power needs of special-purpose wireless devices. Examples
include Google
Iris contact lenses~\cite{iris}, Xbox One wireless controllers~\cite{xbox}, and
Google Chromecast~\cite{chromecast}. Validating that device implementations work
correctly is critical to achieve the design goals of the wireless protocol and
also prevent bugs in shipped products~\cite{wifried,lollipop,surface}.


Runtime validation of the protocol implementations on such devices is
challenging because collecting traces from the device under test (DUT) is often
infeasible. The resource limitations of embedded or battery-powered devices may
cause them to not provide trace collecting capabilities. DUT may contain
proprietary hardware or firmware that hides the implementation details and
prevents testers from collecting traces through source code instrumentation.
Even when collecting trace directly from DUT is possible, the overhead it causes
may alter the behavior of the DUT due to the observer
effect~\cite{mytkowicz2008observer}, threatening the validation results.

An attractive alternative is to use wireless
sniffers to record traffic generated by the DUTs during testing.
Sniffers do not require direct access to the DUT or alter its behavior.
However, due to the fundamentally unpredictable nature of wireless
communications, the packets captured by the sniffer will not exactly match
those received by the DUT.
The sniffer may miss packets that the DUT received, or receive packets that
the DUT missed.
This is true even when using multiple
sniffers~\cite{cheng2006jigsaw,mahajan2006analyzing,bahl2006enhancing}, sniffer
with multiple antennas~\cite{omnipeek}, or in isolated wireless environments.

Since the sniffer trace does not perfectly match the actual trace, uncertainty
arises during protocol implementation validation.  For example, if the DUT fails
to respond correctly to a packet in the sniffer trace, it may be because either the
DUT's implementation is incorrect, or the DUT did not actually receive the
packet, or the DUT's response was missed by the sniffer.  Whenever the DUT's
behavior does not match the specification, there are now two potential
explanations: either the DUT's implementation is wrong, or the sniffer trace is
inaccurate. Accurate validation requires  distinguishing between these two
causes.

We present a new technique enabling validation of protocol implementations using
wireless sniffers. Given a monitor state machine representing the protocol being
validated, we describe a systematic transformation that adds non-deterministic
transitions to incorporate uncertainty introduced by the sniffer. This
augmented validation state machine processes the sniffer trace into a set of
mutated traces, each satisfying the original state machine with a specific
likelihood. If the set is empty, the implementation definitely violates the
protocol. Searching over all the mutated traces is NP-complete, but the approach
can be made practical by applying protocol-oblivious heuristics that limit the
search to likely mutated traces.

Our paper makes the following contributions:
\begin{enumerate}
  \item To the best of our knowledge, we are the first to identify the
    uncertainty problem caused by sniffers in validating wireless protocol
    implementations.
  \item We formalize the problem using a nondeterministic state machine that
    systematically and completely encodes the uncertainty of the
    sniffer trace.
  \item We characterize the NP-completeness of the validation problem, and
    present two protocol-oblivious heuristics to prune the search space and make
    validation possible in practice.
  \item We implement the validation framework and evaluate it using \ns{}
    network simulator~\cite{riley2010ns}. Our framework accurately identifies
    both synthetic and previously unknown violations in \ns{}'s implementations
    of the 802.11 and ARF protocols.
\end{enumerate}

Due to space limitation, proof of lemmas and theorems in this paper
are omitted. They can be found in the technical report~\cite{msr_tech_report}.

\begin{comment}
The rest of this paper is organized as follows.
We motivate the uncertainty problem in Section~\ref{sec:model}.
We then formally describe the problem in Section~\ref{sec:framework},
including the completeness of the augmentation (\S~\ref{subsec:augment}),
hardness analysis (\S~\ref{subsec:hard}) and search algorithms
(\S~\ref{subsec:search}).
We continue by evaluating our framework through two case studies in
Section~\ref{sec:case}.  Finally, we present related works in
Section~\ref{sec:related} and concludes in Section~\ref{sec:conclusion}.
\end{comment}
